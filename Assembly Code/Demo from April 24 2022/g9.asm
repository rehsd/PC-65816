MyCode.65816.asm
.setting "HandleLongBranch", true
.setting "RegA16", true
.setting "RegXY16", true
.include "vars.asm"
.include "romData.asm"

.org $0000          ;wasted portion of ROM
    .word $ABCD     ;need something to write at $00 -- wasting first 32K of ROM and using addresses for RAM
                    ;if starting with .org $8000, assembler ends up writing it to $0000, which won't work
.org $8000          ;start of usable ROM

.include "graphics.asm"
.include "via.asm"
.include "lcd.asm"
.include "keyboard.asm"
.include "mouse.asm"
.include "sound.asm"

reset:
  sei               ;disable interrupts
  cld               ;disable BCD

  clc
  xce
  rep #$30            ;set 16-bit mode
    
  jsr via_init
  jsr sound_init

  rep #$20  ;set acumulator to 16-bit
  .setting "RegA16", true

  jsr keyboard_init

  jsr video_init


  ;starting center pixel for drawing
  lda #160
  sta fill_region_start_x
  lda #120
  sta fill_region_start_y
  lda #%00111100  ;blue green
  sta fill_region_color
  lda #$00
  sta pixel_prev_color
  sta currently_drawing
  jsr gfx_DrawPixel

  ;startup complete
  cli   ;enable interrupts
  jmp loop_label

loop_label:
  ;sit here and loop, process key presses via interrupts as they come in
  sei
  lda kb_rptr
  AND #$00FF      ; 16-bit adjustment to code
  cmp kb_wptr
  cli                   ;Clear Interrupt Disable
  bne key_pressed

  ;Handle KB flags
  ;jmp Handle_KB_flags
  jmp loop_label
irq_label:
  phb
  phd
  rep #%00110000    ;16-bit registers
  pha ;a to stack
  phx ;x to stack
  phy ;y to stack
  
  //Need to check which mode registers are in (8 or 16)?
  //Store & return mode?

  // lda #$41
  // pha
  // //TO DO: print_char_vga is messing up A. Need to PHA, PLA.
  // jsr print_char_vga
  // pla
  // jsr print_hex_vga
  
  ;check interrupts in order of priority
  ;BIT  VIA1_IFR		        ; Check status register for VIA1        ; PS/2 keyboard
  lda  VIA1_IFR		        ; Check status register for VIA1        ; PS/2 keyboard
  and #%10000000
  bne  VIA1_IRQ_Handler		; Branch if VIA1 is interrupt source

  ;No IRQs used by VIA2
  ;BIT  VIA2_IFR		       ; Check status register for VIA2        ; LCD, bar graph
  ;BMI  VIA2_IRQ			     ; Branch if VIA2 is interrupt source

  lda  VIA3_IFR		        ; Check status register for VIA3        ; USB mouse
  and #%10000000
  bne  VIA3_IRQ_Handler		; Branch if VIA3 is interrupt source

  ;Should never get here unless missing a BIT/BMI for the interrupt source
  jmp irq_done
VIA1_IRQ_Handler:     ;PS/2 Keyboard
  ;Only using interrupts for PortA - don't need to check port source
    // ;check interrupt source on VIA IER (T1, T2, CB1, CB2, SR, CA1, CA2)
    // lda IFR1
    // and IER1
    // asl
    // ;bmi VIA1_T1_handler
    // asl
    // ;bmi VIA1_T2_handler
    // asl
    // ;bmi VIA1_CB1_handler
    // asl
    // ;bmi VIA1_CB2_handler
    // asl
    // ;bmi VIA1_SR_handler
    // asl
    // ;bmi VIA1_CA1_handler
    // asl
    // ;bmi VIA1_CA2_handler

  lda kb_flags
  AND #$00FF      ; 16-bit adjustment to code
  AND #RELEASE   ; check if we're releasing a key
  beq read_key   ; otherwise, read the key

  lda kb_flags
  AND #$00FF      ; 16-bit adjustment to code
  eor #RELEASE   ; flip the releasing bit

  sta kb_flags

  lda VIA1_PORTA      ; read key value that is being released
  AND #$00FF      ; 16-bit adjustment to code
  
  cmp #$12       ; left shift
  beq shift_up
  cmp #$59       ; right shift
  beq shift_up 

  jmp irq_done
VIA3_IRQ_Handler:     ;USB Mouse
  jmp Mouse_Interrupt_Handler
irq_done:
  ;return items from stack
  rep #%00110000    ;16-bit registers
  ply ;stack to y
  plx ;stack to x
  pla ;stack to a
  pld
  plb
  rti
Delay:
    .setting "RegA16", true
    rep #$20            ;set acumulator to 16-bit

    pha       ;save current accumulator
    lda delayDuration	;counter start - increase number to shorten delay
    Delayloop:
        clc
        adc #01
        bne Delayloop
    pla
    rts
Delay0:
    .setting "RegA16", true
    rep #$20            ;set acumulator to 16-bit

    pha       ;save current accumulator
    lda #0
    Delayloop0:
        clc
        adc #01
        bne Delayloop0
    pla
    rts

;Convert keyboard scan codes to ASCII values
; *** Set 1 *** See http://www.vetra.com/scancodes.html
; Used for keyboard when running emulator
; This set is incomplete and needs full testing.
// keymap:
//   .byte "?",$1B,"1234567890-=??qwertyuiop[]",$0A,"?asdfghjkl;'`??zxcvbnm,./???",$20,"????"
//   .byte "????????????????????????????????????????????????????????????????"
//   .byte "????????????????????????????????????????????????????????????????"
//   .byte "????????????????????????????????????????????????????????????????"
// keymap_shifted:
//   .byte "?!@#$%^&*()_+??QWERTYUIOP{}??ASDFGHJKL:?~?ZXCVBNM<>?????????"
//   .byte "????????????????????????????????????????????????????????????????"
//   .byte "????????????????????????????????????????????????????????????????"
//   .byte "????????????????????????????????????????????????????????????????"


;PS/2 keyboard scan codes -- Set 2 or 3
keymap:
  .byte "????????????? `?"          ; 00-0F
  .byte "?????q1???zsaw2?"          ; 10-1F
  .byte "?cxde43?? vftr5?"          ; 20-2F
  .byte "?nbhgy6???mju78?"          ; 30-3F
  .byte "?,kio09??./l;p-?"          ; 40-4F
  .byte "??'?[=????",$0a,"]?",$5c,"??"    ; 50-5F     orig:"??'?[=????",$0a,"]?\??"   '\' causes issue with retro assembler - swapped out with hex value 5c
  .byte "?????????1?47???"          ; 60-6F0
  .byte "0.2568",$1b,"??+3-*9??"    ; 70-7F
  .byte "????????????????"          ; 80-8F
  .byte "????????????????"          ; 90-9F
  .byte "????????????????"          ; A0-AF
  .byte "????????????????"          ; B0-BF
  .byte "????????????????"          ; C0-CF
  .byte "????????????????"          ; D0-DF
  .byte "????????????????"          ; E0-EF
  .byte "????????????????"          ; F0-FF
keymap_shifted:
  .byte "????????????? ~?"          ; 00-0F
  .byte "?????Q!???ZSAW@?"          ; 10-1F
  .byte "?CXDE#$?? VFTR%?"          ; 20-2F
  .byte "?NBHGY^???MJU&*?"          ; 30-3F
  .byte "?<KIO)(??>?L:P_?"          ; 40-4F
  .byte "??",$22,"?{+?????}?|??"          ; 50-5F      orig:"??"?{+?????}?|??"  ;nested quote - compiler doesn't like - swapped out with hex value 22
  .byte "?????????1?47???"          ; 60-6F
  .byte "0.2568???+3-*9??"          ; 70-7F
  .byte "????????????????"          ; 80-8F
  .byte "????????????????"          ; 90-9F
  .byte "????????????????"          ; A0-AF
  .byte "????????????????"          ; B0-BF
  .byte "????????????????"          ; C0-CF
  .byte "????????????????"          ; D0-DF
  .byte "????????????????"          ; E0-EF
  .byte "????????????????"          ; F0-FF


.org $FFEE
    .word irq_label   //native 16-bit mode interrupt vector

.org $FFFC
    .word reset
    .word irq_label   //emulation interrupt vector
    